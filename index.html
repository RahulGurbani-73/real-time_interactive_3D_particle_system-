<!DOCTYPE html>
<html>
<head>
    <title>Three.js Interactive Particle System</title>
    <style>
        body { margin: 0; background-color: #000000; overflow: hidden; }
        canvas { display: block; }
    </style>
</head>
<body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        // --- Global Variables ---
        let scene, camera, renderer;
        let particles, geometry, positions;
        const particleCount = 50000;
        const interactionPoint = new THREE.Vector3(0, 0, 0); // Simulated hand position
        const interactionRadius = 5;
        const repulsionStrength = 0.05;

        // --- Initialization ---
        function init() {
            // 1. Scene Setup
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // Set camera position
            camera.position.z = 50;

            // 2. Create Particles
            createParticles();

            // 3. Event Listeners for Interaction and Resizing
            window.addEventListener('mousemove', onMouseMove);
            window.addEventListener('resize', onWindowResize);

            // Start the loop
            animate();
        }

        // --- Particle Creation Function ---
        function createParticles() {
            geometry = new THREE.BufferGeometry();
            positions = new Float32Array(particleCount * 3);
            const originalPositions = new Float32Array(particleCount * 3); // Store original static positions

            // Place particles randomly in a spherical volume
            const sphereRadius = 25;
            for (let i = 0; i < particleCount * 3; i += 3) {
                // Random position within a sphere
                const r = sphereRadius * Math.sqrt(Math.random());
                const theta = Math.random() * 2 * Math.PI;
                const phi = Math.random() * Math.PI;

                const x = r * Math.sin(phi) * Math.cos(theta);
                const y = r * Math.sin(phi) * Math.sin(theta);
                const z = r * Math.cos(phi);

                positions[i] = x;
                positions[i + 1] = y;
                positions[i + 2] = z;

                originalPositions[i] = x;
                originalPositions[i + 1] = y;
                originalPositions[i + 2] = z;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('originalPosition', new THREE.BufferAttribute(originalPositions, 3));

            const material = new THREE.PointsMaterial({
                color: 0xffffee, // Light yellow/white color
                size: 0.15,
                sizeAttenuation: true,
                transparent: true,
                opacity: 0.8
            });

            particles = new THREE.Points(geometry, material);
            scene.add(particles);
            
            // Add a subtle ambient light for better depth perception (optional)
            scene.add(new THREE.AmbientLight(0x404040));
        }

        // --- Interaction Logic (Simulating Hand with Mouse) ---
        function onMouseMove(event) {
            // Convert mouse position to 3D world coordinates on a plane (Z=0)
            const vector = new THREE.Vector3();
            vector.set(
                (event.clientX / window.innerWidth) * 2 - 1,
                -(event.clientY / window.innerHeight) * 2 + 1,
                0.5 // Camera near plane
            );
            
            // Map the screen coordinate to the 3D scene (this is the key mapping step!)
            vector.unproject(camera);
            
            const dir = vector.sub(camera.position).normalize();
            const distance = -camera.position.z / dir.z; 
            
            // Update the simulated hand/interaction point
            interactionPoint.copy(camera.position).add(dir.multiplyScalar(distance));
        }

        // --- Repulsion Physics Update ---
        function updateParticles() {
            const positionsArray = particles.geometry.attributes.position.array;
            const originalPositionsArray = particles.geometry.attributes.originalPosition.array;

            const tempParticlePosition = new THREE.Vector3();
            const tempForceVector = new THREE.Vector3();

            for (let i = 0; i < particleCount; i++) {
                const i3 = i * 3;

                // 1. Get current particle position
                tempParticlePosition.set(positionsArray[i3], positionsArray[i3 + 1], positionsArray[i3 + 2]);

                // 2. Calculate distance to interaction point (mouse/hand)
                const distance = tempParticlePosition.distanceTo(interactionPoint);

                if (distance < interactionRadius) {
                    // 3. Apply Repulsion Force
                    // Direction vector from interaction point to particle
                    tempForceVector.subVectors(tempParticlePosition, interactionPoint).normalize();
                    
                    // Strength decreases with distance
                    const influence = (interactionRadius - distance) / interactionRadius; 
                    tempForceVector.multiplyScalar(repulsionStrength * influence);
                    
                    // Apply force to push particle away
                    positionsArray[i3] += tempForceVector.x;
                    positionsArray[i3 + 1] += tempForceVector.y;
                    positionsArray[i3 + 2] += tempForceVector.z;
                } else {
                    // 4. Decay and return to original position (to make it springy)
                    const originalX = originalPositionsArray[i3];
                    const originalY = originalPositionsArray[i3 + 1];
                    const originalZ = originalPositionsArray[i3 + 2];
                    
                    positionsArray[i3] += (originalX - positionsArray[i3]) * 0.02; // 0.02 is the decay rate
                    positionsArray[i3 + 1] += (originalY - positionsArray[i3 + 1]) * 0.02;
                    positionsArray[i3 + 2] += (originalZ - positionsArray[i3 + 2]) * 0.02;
                }
            }

            particles.geometry.attributes.position.needsUpdate = true; // Tell Three.js the positions changed
        }

        // --- Animation Loop ---
        function animate() {
            requestAnimationFrame(animate);

            // Update physics (repulsion and decay)
            updateParticles();
            
            // Optional: Rotate the whole system slowly
            particles.rotation.y += 0.001; 
            particles.rotation.x += 0.0005;

            renderer.render(scene, camera);
        }

        // --- Handle Window Resizing ---
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Run the main initialization function
        init();

    </script>
</body>
</html>
