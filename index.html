<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cinema Gold Particles</title>
    
    <!-- MediaPipe -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <!-- Import Map -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <style>
        body { margin: 0; overflow: hidden; background: #020202; font-family: 'Helvetica Neue', sans-serif; }
        
        /* High-End UI */
        #ui-container {
            position: absolute; bottom: 40px; left: 50%; transform: translateX(-50%);
            display: flex; flex-direction: column; align-items: center; gap: 20px;
            z-index: 10; pointer-events: none;
        }

        .dock {
            pointer-events: auto;
            background: rgba(15, 15, 15, 0.8); backdrop-filter: blur(20px);
            padding: 10px 20px; border-radius: 100px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            display: flex; gap: 15px; align-items: center;
            box-shadow: 0 20px 50px rgba(0,0,0,0.8);
        }

        .btn {
            background: transparent; border: none; color: #666;
            font-size: 11px; font-weight: 700; letter-spacing: 1.5px; text-transform: uppercase;
            cursor: pointer; transition: all 0.4s cubic-bezier(0.25, 1, 0.5, 1);
            padding: 8px 12px; border-radius: 20px;
        }
        .btn:hover { color: #fff; }
        .btn.active { background: #fff; color: #000; box-shadow: 0 0 20px rgba(255,255,255,0.4); }

        .color-btn {
            width: 18px; height: 18px; border-radius: 50%; cursor: pointer;
            border: 2px solid rgba(255,255,255,0.1); transition: 0.3s;
        }
        .color-btn:hover { transform: scale(1.4); border-color: #fff; }

        /* Loader */
        #loader {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; display: flex; flex-direction: column;
            justify-content: center; align-items: center; z-index: 100;
            transition: opacity 1s ease;
        }
        .loader-text { color: #fff; letter-spacing: 5px; font-size: 12px; margin-top: 15px; opacity: 0.7; }
        
        /* Cam Preview (Minimalist) */
        #cam-preview {
            position: absolute; top: 20px; right: 20px; width: 100px; 
            opacity: 0.2; z-index: 5; border-radius: 6px; transform: scaleX(-1);
            transition: opacity 0.3s;
        }
        #cam-preview:hover { opacity: 1; }
        .input_video { display: none; }
    </style>
</head>
<body>

    <div id="loader">
        <div style="width: 40px; height: 1px; background: #fff;"></div>
        <div class="loader-text">INITIALIZING ENGINE</div>
    </div>

    <video class="input_video" playsinline></video>
    <canvas id="cam-preview"></canvas>

    <div id="ui-container">
        <!-- Shapes -->
        <div class="dock">
            <button class="btn active" onclick="setShape('saturn')">Saturn</button>
            <button class="btn" onclick="setShape('galaxy')">Galaxy</button>
            <button class="btn" onclick="setShape('sphere')">Sphere</button>
            <button class="btn" onclick="setShape('vortex')">Vortex</button>
        </div>
        
        <!-- Colors -->
        <div class="dock" style="padding: 10px 15px; border-radius: 30px; transform: scale(0.9);">
            <div class="color-btn" style="background: #ffaa00;" onclick="setColor('gold')"></div> <!-- Gold -->
            <div class="color-btn" style="background: #00ffff;" onclick="setColor('cyan')"></div> <!-- Sci-Fi -->
            <div class="color-btn" style="background: #ff0055;" onclick="setColor('pink')"></div> <!-- Neon -->
            <div class="color-btn" style="background: #ffffff;" onclick="setColor('white')"></div> <!-- Minimal -->
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // --- HIGH QUALITY SETTINGS ---
        const CONFIG = {
            count: 40000,     // High density for "dust" look
            size: 0.045,      // Smaller = more cinematic
            lerpSpeed: 0.04   // Slower = heavier/smoother feel
        };

        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.015);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 100);
        camera.position.z = 8;

        const renderer = new THREE.WebGLRenderer({ powerPreference: "high-performance", antialias: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);

        // --- CINEMATIC POST PROCESSING ---
        const composer = new EffectComposer(renderer);
        const renderPass = new RenderPass(scene, camera);
        
        // Settings adjusted for sharp, intense glow
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.threshold = 0;
        bloomPass.strength = 1.2;
        bloomPass.radius = 0.5;
        
        composer.addPass(renderPass);
        composer.addPass(bloomPass);

        // --- PARTICLES ---
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(CONFIG.count * 3);
        const targetPositions = new Float32Array(CONFIG.count * 3);
        const colors = new Float32Array(CONFIG.count * 3);
        const randoms = new Float32Array(CONFIG.count); // Individual offset

        const color1 = new THREE.Color(0xffaa00); // Inner (Gold)
        const color2 = new THREE.Color(0xaa4400); // Outer (Dark Orange)
        let targetColor1 = color1.clone();
        let targetColor2 = color2.clone();

        for(let i=0; i<CONFIG.count; i++) {
            positions[i*3] = (Math.random()-0.5)*20;
            positions[i*3+1] = (Math.random()-0.5)*20;
            positions[i*3+2] = (Math.random()-0.5)*20;
            targetPositions[i*3] = positions[i*3];
            colors[i*3] = 1;
            randoms[i] = Math.random();
        }
        
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

        // Create "Spark" Texture
        const canvas = document.createElement('canvas'); canvas.width=32; canvas.height=32;
        const ctx = canvas.getContext('2d');
        const grad = ctx.createRadialGradient(16,16,0,16,16,16);
        grad.addColorStop(0, 'rgba(255,255,255,1)');
        grad.addColorStop(0.3, 'rgba(255,255,255,0.5)');
        grad.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = grad; ctx.fillRect(0,0,32,32);
        const texture = new THREE.CanvasTexture(canvas);

        const material = new THREE.PointsMaterial({
            size: CONFIG.size, map: texture, vertexColors: true,
            blending: THREE.AdditiveBlending, depthWrite: false, transparent: true
        });

        const particleSystem = new THREE.Points(geometry, material);
        scene.add(particleSystem);

        // --- SHAPE MATH ---
        function updateShape(type) {
            // UI
            document.querySelectorAll('.btn').forEach(b => b.classList.remove('active'));
            if(event && event.target) event.target.classList.add('active');

            let idx = 0;
            for(let i=0; i<CONFIG.count; i++) {
                let x,y,z;
                const r = Math.random();
                const randPhi = Math.acos(2 * Math.random() - 1);
                const randTheta = Math.random() * Math.PI * 2;

                if (type === 'saturn') {
                    if (r < 0.5) { // Planet
                        const rad = 2.2;
                        x = rad * Math.sin(randPhi) * Math.cos(randTheta);
                        y = rad * Math.sin(randPhi) * Math.sin(randTheta);
                        z = rad * Math.cos(randPhi);
                    } else { // Rings
                        const ang = Math.random() * Math.PI * 2;
                        const rad = 3.2 + Math.random() * 2.5;
                        x = Math.cos(ang) * rad;
                        z = Math.sin(ang) * rad;
                        y = (Math.random() - 0.5) * 0.15;
                    }
                    // Tilt
                    const tx=x; x = tx*Math.cos(0.4)-y*Math.sin(0.4); y = tx*Math.sin(0.4)+y*Math.cos(0.4);
                }
                else if (type === 'galaxy') {
                    const arms = 3;
                    const spin = i * 0.0003;
                    const angle = spin + (i % arms) * (Math.PI * 2 / arms);
                    const dist = Math.random() * 7;
                    x = Math.cos(angle) * dist;
                    z = Math.sin(angle) * dist;
                    y = (Math.random()-0.5) * (1 - dist/8); 
                }
                else if (type === 'vortex') {
                    const h = (Math.random() - 0.5) * 10;
                    const rad = 1 + Math.abs(h)*0.5 + Math.random();
                    const ang = h * 2 + Math.random();
                    x = Math.cos(ang) * rad;
                    z = Math.sin(ang) * rad;
                    y = h;
                }
                else { // Sphere
                    const rad = 3.5 + Math.random();
                    x = rad * Math.sin(randPhi) * Math.cos(randTheta);
                    y = rad * Math.sin(randPhi) * Math.sin(randTheta);
                    z = rad * Math.cos(randPhi);
                }

                targetPositions[idx] = x;
                targetPositions[idx+1] = y;
                targetPositions[idx+2] = z;
                idx += 3;
            }
        }
        window.setShape = updateShape;

        // --- COLOR SYSTEM ---
        window.setColor = (c) => {
            if(c==='gold') { targetColor1.setHex(0xffaa00); targetColor2.setHex(0xaa4400); }
            if(c==='cyan') { targetColor1.setHex(0x00ffff); targetColor2.setHex(0x0055aa); }
            if(c==='pink') { targetColor1.setHex(0xff00cc); targetColor2.setHex(0x5500aa); }
            if(c==='white') { targetColor1.setHex(0xffffff); targetColor2.setHex(0x888888); }
        };

        // --- TRACKING ---
        const videoElement = document.getElementsByClassName('input_video')[0];
        const previewCanvas = document.getElementById('cam-preview');
        const pCtx = previewCanvas.getContext('2d');
        
        let handDist = 0;
        let targetScale = 1;

        const hands = new window.Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({ maxNumHands: 2, modelComplexity: 1, minDetectionConfidence: 0.5 });
        
        hands.onResults(results => {
            pCtx.clearRect(0,0,100,75);
            pCtx.drawImage(results.image, 0, 0, 100, 75);
            
            if(results.multiHandLandmarks && results.multiHandLandmarks.length === 2) {
                const h1 = results.multiHandLandmarks[0][9];
                const h2 = results.multiHandLandmarks[1][9];
                const d = Math.sqrt((h1.x-h2.x)**2 + (h1.y-h2.y)**2);
                
                // Map distance: 0.1->0.8 becomes Scale 0.5->3.0
                const rawScale = 0.5 + (d * 4.0);
                // Weighted moving average for smoothness
                targetScale = targetScale * 0.9 + rawScale * 0.1; 
                handDist = targetScale;
            } else {
                // Idle breathing
                targetScale = targetScale * 0.95 + 1.0 * 0.05;
                handDist = targetScale;
            }
        });

        const cam = new window.Camera(videoElement, {
            onFrame: async () => { await hands.send({image: videoElement}); },
            width: 640, height: 480
        });

        cam.start().then(() => {
            document.getElementById('loader').style.opacity = 0;
            setTimeout(()=>document.getElementById('loader').style.display='none', 1000);
        });

        // --- ANIMATION LOOP ---
        const clock = new THREE.Clock();
        window.setShape('saturn'); // Init

        function animate() {
            requestAnimationFrame(animate);
            const time = clock.getElapsedTime();

            // 1. Color Lerp
            color1.lerp(targetColor1, 0.05);
            color2.lerp(targetColor2, 0.05);

            // 2. Global Transform
            particleSystem.scale.setScalar(handDist + Math.sin(time)*0.05); // Subtle breath
            particleSystem.rotation.y = time * 0.1;

            const pos = geometry.attributes.position.array;
            const col = geometry.attributes.color.array;

            for(let i=0; i<CONFIG.count; i++) {
                const idx = i*3;
                
                // 3. Fluid Physics (The "Not Perfect" Fix)
                // Instead of straight Lerp, add Noise
                const tx = targetPositions[idx];
                const ty = targetPositions[idx+1];
                const tz = targetPositions[idx+2];

                // Move 5% towards target
                pos[idx] += (tx - pos[idx]) * CONFIG.lerpSpeed;
                pos[idx+1] += (ty - pos[idx+1]) * CONFIG.lerpSpeed;
                pos[idx+2] += (tz - pos[idx+2]) * CONFIG.lerpSpeed;

                // Add "Floating Dust" Motion (Sine waves based on position + time)
                const noise = 0.004;
                pos[idx] += Math.sin(time * 0.5 + pos[idx+1]) * noise;
                pos[idx+1] += Math.cos(time * 0.3 + pos[idx]) * noise;
                pos[idx+2] += Math.sin(time * 0.4 + pos[idx]) * noise;

                // 4. Color Gradient (Hot Center, Cold Edge)
                const dist = Math.sqrt(pos[idx]**2 + pos[idx+1]**2 + pos[idx+2]**2);
                const alpha = Math.max(0, 1 - (dist/6)); // 0 to 1 based on center

                col[idx] = color1.r * alpha + color2.r * (1-alpha);
                col[idx+1] = color1.g * alpha + color2.g * (1-alpha);
                col[idx+2] = color1.b * alpha + color2.b * (1-alpha);
            }

            geometry.attributes.position.needsUpdate = true;
            geometry.attributes.color.needsUpdate = true;
            composer.render();
        }

        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
